#include <Servo.h>
#include <SITL.h>

SITL Sim;
Servo servo;

// Constantes de conversão de ângulo
double DEG2RAD = 3.14159265 / 180;
double RAD2DEG = 180 / 3.14159265;

// Tempo de amostragem
double T_Program = 0.01;
unsigned long T_Program_micros = T_Program * 1000000;
unsigned long timer_run;

// Variáveis do PID
unsigned long currentTime, previousTime;
double elapsedTime, elapsedTimeSeg;
double errorPID;
double lastError;
double input, output, setPoint;
double cumError, rateError;
double okp, oki, okd;
float kp = 0.4;
float ki = 0.0;
float kd = 0.136;
double out;

// Saturação e atuador real
double Actuator_reduction = 5;
double Max_Actuator_Angle = 10 * DEG2RAD;
double Max_servo_Angle = Max_Actuator_Angle * Actuator_reduction;

// Variáveis da simulação
float theta, servo_command, Alt_prev;
int parachute = 0;
float GyroY, AccX, AccZ, Alt;

void setup() {
  Serial.begin(1000000);   
  servo.attach(10);
  servo.write(90);
  Sim.StartSITL();
}

void loop() {
  // Tempo de amostragem
  if (micros() >= timer_run + T_Program_micros) {  
    double dt = double(micros() - timer_run);
    // Converter microssegundos para segundos
    dt /= 1000000;
    timer_run = micros();  

    // Obter dados da simulação
    Sim.getSimData(GyroY, AccX, AccZ, Alt);

    // Integrar os giroscópios para encontrar o ângulo
    theta += (GyroY * DEG2RAD) * dt;

    // Definir setpoint e calcular PID
    double setpoint = 10 * DEG2RAD;
    out = PID(setpoint, theta);
    servo_command = PID2Servo(out);
    
    // Verificar condição para abrir paraquedas
    parachute = Deploy_Parachute(Alt);

    // Controlar o servo real
    double servo_center = 90;
    servo.write(-servo_command + servo_center); 
     
    // Enviar comando para servo simulado e paraquedas
    Sim.sendCommand(servo_command, parachute); 
  }
}

double PID(double set_point, double inp) {
  currentTime = micros();  // Obter o tempo atual
  elapsedTime = (double)(currentTime - previousTime);  // Calcular o tempo decorrido desde a última computação
  elapsedTimeSeg = elapsedTime / 1000000;
    
  errorPID = set_point - inp;  // Determinar o erro
  rateError = (errorPID - lastError) / elapsedTimeSeg;  // Calcular a derivada
  cumError += ((lastError + ((errorPID - lastError) / 2)) * elapsedTimeSeg);  // Calcular a integral
  out = kp * errorPID + ki * cumError + kd * rateError;
  
  lastError = errorPID;  // Armazenar o erro atual
  previousTime = currentTime;  // Armazenar o tempo atual
  return out;
}

double PID2Servo(double out) {
  // Calcular o comando do atuador
  double servo_command = out * Actuator_reduction;
  
  // Aplicar saturação
  if (servo_command > Max_servo_Angle) { servo_command = Max_servo_Angle; }
  if (servo_command < -Max_servo_Angle) { servo_command = -Max_servo_Angle; }
  servo_command *= RAD2DEG;
  return servo_command;  
}

int Deploy_Parachute(double Alt) {
  // Verificar condição para abrir o paraquedas
  if (Alt > 10 && Alt_prev > Alt) {
    parachute = 1;
  }
  Alt_prev = Alt;
  return parachute; 
}
